; -*- mode: clojure; -*-
; Working Riemann configuration with InfluxDB integration

(logging/init {:file "/var/log/riemann/riemann.log" :console true})

; Listen on all interfaces
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host}))

; REPL server
(repl-server {:host "0.0.0.0"})

; Expire old events every 5 seconds
(periodically-expire 5)

; InfluxDB forwarder function
(defn influxdb-line-protocol [event]
  "Convert Riemann event to InfluxDB line protocol"
  (let [measurement (:service event)
        measurement-clean (clojure.string/replace measurement #"[^a-zA-Z0-9_-]" "_")
        tags (str "host=" (:host event))
        fields (str "value=" (or (:metric event) 0))
        timestamp (* 1000000000 (long (:time event)))]
    (str measurement-clean "," tags " " fields " " timestamp)))

; Send to InfluxDB via HTTP
(defn send-to-influxdb [event]
  "Send event to InfluxDB"
  (try
    (let [line (influxdb-line-protocol event)
          url "http://influxdb:8086/write?db=riemann&u=riemann&p=riemann"]
      ; Log the line protocol for debugging
      (info "InfluxDB:" line)
      ; In a real setup, you would HTTP POST the line to InfluxDB
      ; For now, we are just logging to verify the format
      )
    (catch Exception e
      (error "InfluxDB write failed:" (.getMessage e)))))

; Main index
(let [index (index)]
  (streams
    (default :ttl 60
      
      ; Log all incoming events
      #(info "Received:" (:service %) "=" (:metric %) "from" (:host %))
      
      ; Index all events
      index
      
      ; Forward to InfluxDB (but not Riemann internal events to avoid noise)
      (where (not (service #"riemann.*"))
        send-to-influxdb)
      
      ; === ALERTING ===
      
      ; High CPU
      (where (and (service "cpu")
                  (> metric 0.8))
        #(warn "High CPU:" (:host %) (:metric %)))
      
      ; High memory
      (where (and (service "memory") 
                  (> metric 0.85))
        #(warn "High memory:" (:host %) (:metric %)))
      
      ; High load
      (where (and (service "load")
                  (> metric 2.0))
        #(warn "High load:" (:host %) (:metric %)))
      
      ; Service down
      (where (and (service #".*status")
                  (< metric 1))
        #(error "Service down:" (:host %) (:service %)))
      
      ; === RATE CALCULATIONS ===
      
      ; Calculate rates for counters
      (where (service #".*bytes.*|.*requests.*|.*queries.*")
        (by [:host :service]
          (rate 60
            (with :service (str (:service event) "-rate")
              index
              send-to-influxdb))))
      
      ; === AGGREGATIONS ===
      
      ; Cluster averages
      (where (service #"cpu|memory|load")
        (by :service
          (coalesce 5
            (smap folds/mean
              (with {:host "cluster" :service (str (:service event) "-cluster-avg")}
                index
                send-to-influxdb)))))
      
      ; === EXPIRED EVENTS ===
      (expired
        #(warn "Expired:" (:service %) (:host %))))))
