; -*- mode: clojure; -*-
; Riemann configuration with inline Backup Monitoring

(require '[clojure.java.io :as io]
         '[clojure.string :as str])
(import '[java.io File]
        '[java.time LocalDateTime ZoneId]
        '[java.time.format DateTimeFormatter])

(logging/init {:file "/var/log/riemann/riemann.log" :console true})

; Listen on all interfaces
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host}))

; REPL server
(repl-server {:host "0.0.0.0"})

; Expire old events every 5 seconds
(periodically-expire 5)

; === BACKUP MONITORING FUNCTIONS ===
(def backup-root-dir "/home/tmb/alfresco-backups")

(defn hours-since [file]
  "Calculate hours since file was last modified"
  (let [now (System/currentTimeMillis)
        modified (.lastModified file)
        hours (/ (- now modified) 1000 60 60)]
    hours))

(defn get-backup-files []
  "Get all backup files from backup directory"
  (let [backup-dir (io/file backup-root-dir)]
    (if (.exists backup-dir)
      (->> (.listFiles backup-dir)
           (filter #(.isFile %))
           (filter #(or (str/ends-with? (.getName %) ".tar.gz")
                       (str/ends-with? (.getName %) ".tar")
                       (str/ends-with? (.getName %) ".sql"))))
      [])))

(defn analyze-backup-freshness []
  "Analyze backup freshness"
  (let [files (get-backup-files)]
    (if (empty? files)
      {:newest-age-hours 999999 :oldest-age-hours 999999 :count 0}
      (let [ages (map hours-since files)
            newest (apply min ages)
            oldest (apply max ages)]
        {:newest-age-hours newest
         :oldest-age-hours oldest
         :count (count files)}))))

(defn calculate-health-score []
  "Calculate overall backup health score (0.0 to 1.0)"
  (let [freshness (analyze-backup-freshness)
        files (get-backup-files)
        
        ; Freshness score (1.0 if < 24 hours, decreasing)
        freshness-score (max 0.0 (min 1.0 (/ (- 48 (:newest-age-hours freshness)) 48)))
        
        ; Count score (1.0 if >= 5 files, decreasing)
        count-score (max 0.0 (min 1.0 (/ (count files) 5)))
        
        ; Storage score (assume good if files exist)
        storage-score (if (> (count files) 0) 1.0 0.0)]
    
    ; Weighted average
    (/ (+ (* freshness-score 0.5)
          (* count-score 0.3) 
          (* storage-score 0.2)) 1.0)))

(defn collect-simple-backup-metrics []
  "Collect simplified backup metrics"
  (try
    (let [freshness (analyze-backup-freshness)
          files (get-backup-files)
          health-score (calculate-health-score)
          total-size (apply + (map #(.length %) files))]
      
      [{:service "backup.health.score"
        :metric health-score
        :state (cond (>= health-score 0.8) "ok"
                     (>= health-score 0.5) "warning"
                     :else "critical")
        :description (format "Backup health score: %.2f" health-score)
        :host "trust-server"}
       
       {:service "backup.freshness.age_hours"
        :metric (:newest-age-hours freshness)
        :state (cond (< (:newest-age-hours freshness) 25) "ok"
                     (< (:newest-age-hours freshness) 49) "warning"
                     :else "critical")
        :description (format "Newest backup age: %.1f hours" (:newest-age-hours freshness))
        :host "trust-server"}
       
       {:service "backup.count.total"
        :metric (count files)
        :state (if (> (count files) 0) "ok" "critical")
        :description (format "Total backup files: %d" (count files))
        :host "trust-server"}
       
       {:service "backup.storage.total_bytes"
        :metric total-size
        :state "ok"
        :description (format "Total backup storage: %.1f MB" (/ total-size 1024 1024))
        :host "trust-server"}])
    
    (catch Exception e
      (error "Backup metrics collection failed:" (.getMessage e))
      [{:service "backup.monitor.error"
        :metric 0
        :state "critical"
        :description (str "Backup monitoring error: " (.getMessage e))
        :host "trust-server"}])))

; InfluxDB forwarder function  
(defn influxdb-line-protocol [event]
  "Convert Riemann event to InfluxDB line protocol"
  (let [measurement (:service event)
        measurement-clean (str/replace measurement #"[^a-zA-Z0-9_.-]" "_")
        tags (str "host=" (:host event))
        fields (str "value=" (or (:metric event) 0))
        timestamp (* 1000000000 (long (:time event)))]
    (str measurement-clean "," tags " " fields " " timestamp)))

; Send to InfluxDB via HTTP
(defn send-to-influxdb [event]
  "Send event to InfluxDB"
  (try
    (let [line (influxdb-line-protocol event)]
      (info "InfluxDB:" line))
    (catch Exception e
      (error "InfluxDB write failed:" (.getMessage e)))))

; Backup monitoring every 5 minutes
(let [backup-task 
      (fn []
        (try
          (let [backup-events (collect-simple-backup-metrics)]
            (info "Collected" (count backup-events) "backup events")
            (doseq [event backup-events]
              (let [processed-event (merge {:time (unix-time) :ttl 600} event)]
                (send-to-influxdb processed-event)
                (info "Backup:" (:service processed-event) "=" (:metric processed-event) "state=" (:state processed-event)))))
          (catch Exception e
            (error "Backup monitoring failed:" (.getMessage e)))))
      
      backup-scheduler (java.util.concurrent.Executors/newScheduledThreadPool 1)]
  
  ; Schedule backup monitoring to run every 5 minutes, starting after 30 seconds
  (.scheduleWithFixedDelay backup-scheduler backup-task 30 300 java.util.concurrent.TimeUnit/SECONDS))

; Main index
(let [index (index)]
  (streams
    (default :ttl 60

      ; Log all incoming events
      #(info "Received:" (:service %) "=" (:metric %) "from" (:host %))

      ; Index all events
      index

      ; Forward to InfluxDB (but not Riemann internal events to avoid noise)
      (where (not (service #"riemann.*"))
        send-to-influxdb)

      ; === BACKUP ALERTING ===
      
      ; Critical backup alerts
      (where (and (service #"backup\..*")
                  (state "critical"))
        #(error "CRITICAL BACKUP ALERT:" (:service %) "-" (:description %)))
      
      ; Backup health score alerts
      (where (and (service "backup.health.score")
                  (< metric 0.5))
        #(warn "LOW BACKUP HEALTH SCORE:" (:metric %) "-" (:description %)))
      
      ; Stale backup alerts
      (where (and (service "backup.freshness.age_hours")
                  (> metric 25))
        #(warn "STALE BACKUP:" (:metric %) "hours old -" (:description %)))

      ; === EXPIRED EVENTS ===
      (expired
        #(warn "Expired:" (:service %) (:host %))))))
