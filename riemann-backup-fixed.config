; -*- mode: clojure; -*-
; Riemann configuration with Fixed Backup Monitoring

(require '[clojure.java.io :as io]
         '[clojure.string :as str])
(import '[java.io File])

(logging/init {:file "/var/log/riemann/riemann.log" :console true})

; Listen on all interfaces
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host}))

; REPL server
(repl-server {:host "0.0.0.0"})

; Expire old events every 5 seconds
(periodically-expire 5)

; === FIXED BACKUP MONITORING ===
(def backup-root-dir "/home/tmb/alfresco-backups")

(defn hours-since [file]
  "Calculate hours since file was last modified, return double"
  (let [now (System/currentTimeMillis)
        modified (.lastModified file)
        hours (double (/ (- now modified) 1000 60 60))]
    hours))

(defn collect-backup-metrics []
  "Collect comprehensive backup metrics with proper type casting"
  (info "=== Starting backup metrics collection ===")
  (try
    (let [backup-files (->> (file-seq (io/file backup-root-dir))
                           (filter #(.isFile %))
                           (filter #(or (.endsWith (.getName %) ".tar.gz")
                                       (.endsWith (.getName %) ".sql")
                                       (.endsWith (.getName %) ".tar"))))
          file-count (long (count backup-files))
          total-size (long (apply + (map #(.length %) backup-files)))
          newest-age (if (empty? backup-files) 
                       999999.0
                       (double (apply min (map hours-since backup-files))))
          oldest-age (if (empty? backup-files) 
                       999999.0
                       (double (apply max (map hours-since backup-files))))
          ; Calculate health score with proper casting
          freshness-score (double (max 0.0 (min 1.0 (/ (- 48.0 newest-age) 48.0))))
          count-score (double (max 0.0 (min 1.0 (/ file-count 5.0))))
          health-score (double (/ (+ (* freshness-score 0.7) (* count-score 0.3)) 1.0))]
      
      (info "Found" file-count "backup files, newest age:" (format "%.1f" newest-age) "hours, health score:" (format "%.2f" health-score))
      
      [{:service "backup.health.score"
        :metric health-score
        :state (cond (>= health-score 0.8) "ok"
                     (>= health-score 0.5) "warning"
                     :else "critical")
        :description (format "Backup health score: %.2f" health-score)
        :host "trust-server"}
       
       {:service "backup.freshness.age_hours"
        :metric newest-age
        :state (cond (< newest-age 25.0) "ok"
                     (< newest-age 49.0) "warning"
                     :else "critical")
        :description (format "Newest backup age: %.1f hours" newest-age)
        :host "trust-server"}
       
       {:service "backup.count.total"
        :metric file-count
        :state (if (> file-count 0) "ok" "critical")
        :description (format "Total backup files: %d" file-count)
        :host "trust-server"}
       
       {:service "backup.storage.total_mb"
        :metric (double (/ total-size 1024.0 1024.0))
        :state "ok"
        :description (format "Total backup storage: %.1f MB" (/ total-size 1024.0 1024.0))
        :host "trust-server"}
       
       {:service "backup.retention.age_spread"
        :metric (double (- oldest-age newest-age))
        :state "ok"
        :description (format "Backup age spread: %.1f hours" (- oldest-age newest-age))
        :host "trust-server"}])
    
    (catch Exception e
      (error "Backup metrics collection failed:" (.getMessage e))
      [{:service "backup.monitor.error"
        :metric 0.0
        :state "critical"
        :description (str "Backup monitoring error: " (.getMessage e))
        :host "trust-server"}])))

; InfluxDB forwarder function  
(defn influxdb-line-protocol [event]
  "Convert Riemann event to InfluxDB line protocol"
  (let [measurement (:service event)
        measurement-clean (str/replace measurement #"[^a-zA-Z0-9_.-]" "_")
        tags (str "host=" (:host event))
        fields (str "value=" (or (:metric event) 0.0))
        timestamp (* 1000000000 (long (:time event)))]
    (str measurement-clean "," tags " " fields " " timestamp)))

; Send to InfluxDB via HTTP
(defn send-to-influxdb [event]
  "Send event to InfluxDB"
  (try
    (let [line (influxdb-line-protocol event)]
      (info "InfluxDB:" line))
    (catch Exception e
      (error "InfluxDB write failed:" (.getMessage e)))))

; Backup monitoring every 5 minutes (300 seconds)
(let [backup-task 
      (fn []
        (try
          (let [backup-events (collect-backup-metrics)]
            (info "Collected" (count backup-events) "backup events")
            (doseq [event backup-events]
              (let [processed-event (merge {:time (unix-time) :ttl 600} event)]
                (send-to-influxdb processed-event)
                (info "Backup:" (:service processed-event) "=" (format "%.2f" (double (:metric processed-event))) "state=" (:state processed-event)))))
          (catch Exception e
            (error "Backup monitoring failed:" (.getMessage e)))))
      
      backup-scheduler (java.util.concurrent.Executors/newScheduledThreadPool 1)]
  
  (info "Scheduling backup monitoring every 5 minutes, starting after 30 seconds...")
  ; Schedule backup monitoring to run every 5 minutes, starting after 30 seconds
  (.scheduleWithFixedDelay backup-scheduler backup-task 30 300 java.util.concurrent.TimeUnit/SECONDS))

; Main index
(let [index (index)]
  (streams
    (default :ttl 60

      ; Log all incoming events
      #(info "Event:" (:service %) "=" (:metric %) "from" (:host %))

      ; Index all events
      index

      ; Forward to InfluxDB (but not Riemann internal events to avoid noise)
      (where (not (service #"riemann.*"))
        send-to-influxdb)

      ; === BACKUP ALERTING ===
      
      ; Critical backup alerts
      (where (and (service #"backup\..*")
                  (state "critical"))
        #(error "CRITICAL BACKUP ALERT:" (:service %) "-" (:description %)))
      
      ; Backup health score alerts
      (where (and (service "backup.health.score")
                  (< metric 0.5))
        #(warn "LOW BACKUP HEALTH SCORE:" (:metric %) "-" (:description %)))
      
      ; Stale backup alerts
      (where (and (service "backup.freshness.age_hours")
                  (> metric 25))
        #(warn "STALE BACKUP:" (:metric %) "hours old -" (:description %)))

      ; === EXPIRED EVENTS ===
      (expired
        #(warn "Expired:" (:service %) (:host %))))))
