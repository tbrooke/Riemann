; -*- mode: clojure; -*-
; Working Riemann configuration with InfluxDB integration

(load-file "/opt/riemann/postgres-monitor/postgres_monitor.clj")
(require '[postgres-monitor :as pg])

(logging/init {:file "/var/log/riemann/riemann.log" :console true})

; Listen on all interfaces
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host}))

; Connect to postgres
(pg/configure-db! {:host "trust-server-postgres-local"
                   :port 5432
                   :dbname "alfresco"
                   :user "alfresco"
                   :password "alfresco"})

; REPL server
(repl-server {:host "0.0.0.0"})

; Expire old events every 5 seconds
(periodically-expire 5)

; InfluxDB forwarder function
(defn influxdb-line-protocol [event]
  "Convert Riemann event to InfluxDB line protocol"
  (let [measurement (:service event)
        measurement-clean (clojure.string/replace measurement #"[^a-zA-Z0-9_-]" "_")
        tags (str "host=" (:host event))
        fields (str "value=" (or (:metric event) 0))
        timestamp (* 1000000000 (long (:time event)))]
    (str measurement-clean "," tags " " fields " " timestamp)))

; Send to InfluxDB via HTTP
(defn send-to-influxdb [event]
  "Send event to InfluxDB"
  (try
    (let [line (influxdb-line-protocol event)
          url "http://influxdb:8086/write?db=riemann&u=riemann&p=riemann"]
      ; Log the line protocol for debugging
      (info "InfluxDB:" line)
      ; In a real setup, you would HTTP POST the line to InfluxDB
      ; For now, we are just logging to verify the format
      )
    (catch Exception e
      (error "InfluxDB write failed:" (.getMessage e)))))

; PostgreSQL metrics collection every 30 seconds - MOVED AFTER FUNCTION DEFINITIONS
(let [postgres-task 
      (fn []
        (try
          (let [postgres-events (pg/collect-all-postgres-metrics)]
            (info "Collected" (count postgres-events) "PostgreSQL events")
            (doseq [event postgres-events]
              ; Process each event through the main streams - using a temporary approach
              (let [processed-event (merge {:time (unix-time) :ttl 120} event)]
                ; Send to InfluxDB directly
                (send-to-influxdb processed-event)
                ; Log key metrics
                (info "PostgreSQL:" (:service processed-event) "=" (:metric processed-event)))))
          (catch Exception e
            (error "PostgreSQL monitoring failed:" (.getMessage e))
            (let [error-event {:service "postgres.monitor.error"
                              :state "critical"
                              :description (str "Monitor error: " (.getMessage e))
                              :time (unix-time)
                              :ttl 120
                              :host "riemann-server"}]
              (send-to-influxdb error-event)))))
      
      postgres-scheduler (java.util.concurrent.Executors/newScheduledThreadPool 1)]
  
  ; Schedule the task to run every 30 seconds, starting after 10 seconds
  (.scheduleWithFixedDelay postgres-scheduler postgres-task 10 30 java.util.concurrent.TimeUnit/SECONDS))

; Main index
(let [index (index)]
  (streams
    (default :ttl 60

      ; Log all incoming events
      #(info "Received:" (:service %) "=" (:metric %) "from" (:host %))

      ; Index all events
      index

      ; Forward to InfluxDB (but not Riemann internal events to avoid noise)
      (where (not (service #"riemann.*"))
        send-to-influxdb)

      ; === POSTGRESQL ALERTING ===
      ; Alert on connection limits (adjust threshold as needed)
      (where (and (service "postgres.alfresco.connections.total")
                  (> metric 80))
        #(warn "High PostgreSQL connections:" (:metric %) "active connections"))

      ; Alert on low cache hit ratio
      (where (and (service #"postgres\..*\.cache_hit_ratio")
                  (< metric 0.8))
        #(warn "Low PostgreSQL cache hit ratio:" (:metric %) "for" (:service %)))

      ; Alert on monitoring health
      (where (and (service "postgres.monitor.health")
                  (state "critical"))
        #(error "PostgreSQL monitoring failed:" (:description %)))

      ; Alert on deadlocks
      (where (and (service #"postgres\..*\.deadlocks")
                  (> metric 0))
        #(warn "PostgreSQL deadlocks detected:" (:metric %) "for" (:service %)))

      ; Alert on too many idle in transaction connections
      (where (and (service #"postgres\..*\.connections\.idle_in_transaction")
                  (> metric 5))
        #(warn "Too many idle in transaction connections:" (:metric %)))

      ; === EXISTING ALERTING ===

      ; High CPU
      (where (and (service "cpu")
                  (> metric 0.8))
        #(warn "High CPU:" (:host %) (:metric %)))

      ; High memory
      (where (and (service "memory")
                  (> metric 0.85))
        #(warn "High memory:" (:host %) (:metric %)))

      ; High load
      (where (and (service "load")
                  (> metric 2.0))
        #(warn "High load:" (:host %) (:metric %)))

      ; Service down
      (where (and (service #".*status")
                  (< metric 1))
        #(error "Service down:" (:host %) (:service %)))

      ; === RATE CALCULATIONS ===

      ; Calculate rates for counters (including PostgreSQL transactions)
      (where (service #".*bytes.*|.*requests.*|.*queries.*|postgres\..*\.transactions\..*")
        (by [:host :service]
          (rate 60
            (with :service (str (:service event) "-rate")
              index
              send-to-influxdb))))

      ; === AGGREGATIONS ===

      ; Cluster averages (including PostgreSQL metrics)
      (where (service #"cpu|memory|load|postgres\..*\.connections\.total|postgres\..*\.cache_hit_ratio")
        (by :service
          (coalesce 5
            (smap folds/mean
              (with {:host "cluster" :service (str (:service event) "-cluster-avg")}
                index
                send-to-influxdb)))))

      ; === EXPIRED EVENTS ===
      (expired
        #(warn "Expired:" (:service %) (:host %))))))
